Metadata-Version: 1.1
Name: sourcerer
Version: 0.0.3
Summary: Library to programatically genrate python source code
Home-page: https://github.com/LISTERINE/sourcerer
Author: Jonathan Ferretti
Author-email: jonathan.m.ferretti@gmail.com
License: BSD
Description: ===============================
        sourcerer
        ===============================
        
        .. image:: https://img.shields.io/travis/LISTERINE/sourcerer.svg
                :target: https://travis-ci.org/LISTERINE/sourcerer
        
        .. image:: https://img.shields.io/pypi/v/sourcerer.svg
                :target: https://pypi.python.org/pypi/sourcerer
        
        Programatically genrate python source code
        
        
        Generate code from code:
        ------------------------
        .. code-block:: python
        
            from yaml import load
            from sourcerer import Document, FunctionDef, DecoratorDef, Return, Str, Name, Call, Assignment
            from sys import argv
        
            # Create a document to put our code in
            doc = Document()
        
            # Open our yml file and read it in
            api = load(open(argv[1], 'r').read())
        
            rapi = Assignment("rapi",
                       Call(name="Blueprint",
                            arg_names=[Str(api['basePath'].lstrip('/')), '__name__'],
                            kwarg_pairs={'template_folder': Str('templates')}))
            doc.add_child(rapi)
        
            for path in api['paths']:
                route = [DecoratorDef(name="rapi.route", arg_names=[Str(path)]), # A decorator: @routename("mypath")
                         FunctionDef(name=Name(path)), # A function: def routename():
                         Return()] # A return statement: return
        
                doc.create_lineage(route) # Cascade these objects into the main document scope
                                          # ...
                                          # @routename("mypath")
                                          # def routename():
                                          #     return
                                          # ...
        
            doc.output() # Send output to standard out (output to file optional)
        
        Generate code from Spellbooks
        -----------------------------
        
        Source code can also be generated by ingesting and parsing a config document (ex. yaml, json, xml...), known as a Spellbook.
        Spellbooks can be parsed into source code be defining a schema, called a Syntax Map.
        
        Example Spellbook (YAML):
        """""""""""""""""""""""""
        .. code-block:: yaml
        
            functions:
                func1:
                    args: ['thing1', 'thing2']
                    kwargs: {"key1": "val1"}
                    varargs: false
                    keywords: false
                    ret:
                        value:
                            true
        
        Example Syntax Map to parse this Spellbook:
        """""""""""""""""""""""""""""""""""""""""""
        .. code-block:: python
        
            # Without inline comments
            {"functions": {'type': FunctionDef,
                           'key': 'name',
                           'value_map': {'args': 'arg_names',
                                         'kwargs': 'kwarg_pairs',
                                         'varargs': 'varargs',
                                         'keywords': 'keywords'},
                           'children':{'ret':'return'}},
             "return": {'type': Return,
                         'value_map': {'value':'val'}}
            }
        
            # With inline comments
            {"functions": {'type': FunctionDef, # Each top level entry under functions is a FunctionDef
                           'key': 'name', # The functions key (func1) is the value to the name argument for the FunctionDef
                           'value_map': {'args': 'arg_names',  # Define what args are called in the markups schema
                                         'kwargs': 'kwarg_pairs',
                                         'varargs': 'varargs',
                                         'keywords': 'keywords'},
                           'children':{'ret':'return'}}, # When top-level objects are seen their values will be 
                                                         # pared as well, building a new object from the mapping 
                                                         # they specify and then appended to this object
             "return": {'type': Return,
                         'value_map': {'value':'val'}}
            }
        
        Building a Syntax Map for a Spellbook:
        """"""""""""""""""""""""""""""""""""""
        Your Syntax Maps top-level keys define what your Spellbook top-level sections are containing. The values of your Syntax Map top-level keys are dictionaries defining how to handle the contents of your Spellbook sections.
        
        In the given example, the only top-level Spellbook section is 'functions'. In the Syntax Map, the 'functions' key's value says several things:
        
        1. For each child node encountered, create a new FunctionObj (defined by 'type')
        
        2. The key defining each child node is the 'name' argument for the FunctionObj
        
        3. The sub-keys of the child node are properties of the FunctionObj. The values of those sub-keys are can be one of two things:
        
           * If the value is in the value map, it is an argument to FunctionObj
        
           * If the value is in the children map, it should be placed into the scope of the FunctionObj. The value will be looked up in the Syntax Map top-level to see if it can be be instantiated into a new sourcerer object.
        
        The Syntax Map schema should consist of:
        ****************************************
        * type (required): The class name to instantiate
        
        * key (required): what the key for the node represents
        
        * value_map (required): map properties to arguments to the class
        
        * children: values that should be instantiated and placed into the current nodes child scope
        
        
        Using a Syntax Map and Spellbook to generate your source:
        """""""""""""""""""""""""""""""""""""""""""""""""""""""""
        Based on the example Syntax Map and the Example YAML, the following will write the resulting source code to stardard out
        
        .. code-block:: python
        
            from sourcerer import YAMLProcessor
        
            gen = YAMLProcessor()
            gen.load('sample_data/sample.yml')
            gen.output()
        
        
        
        Features
        --------
        
        * TODO
        
        
        
        
        History
        -------
        
        0.0.3 (2015-04-15)
        ---------------------
        
        * First release on PyPI.
        
Keywords: sourcerer
Platform: UNKNOWN
Classifier: Development Status :: 2 - Pre-Alpha
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: BSD License
Classifier: Natural Language :: English
Classifier: Programming Language :: Python :: 2
Classifier: Programming Language :: Python :: 2.6
Classifier: Programming Language :: Python :: 2.7
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.3
Classifier: Programming Language :: Python :: 3.4
