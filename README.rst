=========
sourcerer
=========

.. image:: https://img.shields.io/travis/LISTERINE/sourcerer.svg
        :target: https://travis-ci.org/LISTERINE/sourcerer

.. image:: https://img.shields.io/pypi/v/sourcerer.svg
        :target: https://pypi.python.org/pypi/sourcerer

Programatically genrate python source code


Generate code from code:
------------------------
.. code-block:: python

    from yaml import load
    from sourcerer import Document, FunctionDef, DecoratorDef, Return, Str, Name, Call, Assignment, Attribute
    from sys import argv

    # Create a document to put our code in
    doc = Document()

    # Open our yml file and read it in
    api = load(open(argv[1], 'r').read())

    blueprint = Name(api['basePath'])

    bp = Assignment(blueprint,
                    Call(name="Blueprint",
                         arg_names=[Str(blueprint), '__name__'],
                         kwarg_pairs={'template_folder': Str('templates')}))

    doc.add_child(bp)

    for path in api['paths']:
        route = [DecoratorDef(name=Attribute(caller_list=[blueprint], name=Name('route')),
                              arg_names=[Str(path)]), # A decorator: @routename("mypath")
                 FunctionDef(name=Name(path)), # A function: def routename():
                 Return()] # A return statement: return

        doc.create_lineage(route) # Cascade these objects into the main document scope
                                  # ...
                                  # @routename("mypath")
                                  # def routename():
                                  #     return
                                  # ...

    doc.output() # Send output to standard out (output to file optional)

Generate code from Spellbooks
-----------------------------

Source code can also be generated by ingesting and parsing a config document (ex. yaml, json, xml...), known as a Spellbook.
Spellbooks can be parsed into source code be defining a schema, called a Syntax Map.

Example Spellbook (YAML):
"""""""""""""""""""""""""
.. code-block:: yaml

    functions:
        func1:
            args: ['thing1', 'thing2']
            kwargs: {"key1": "val1"}
            varargs: false
            keywords: false
            ret:
                value:
                    true

Example Syntax Map to parse this Spellbook:
"""""""""""""""""""""""""""""""""""""""""""
.. code-block:: python

    # Without inline comments
    {"functions": {'type': FunctionDef,
                   'key': 'name',
                   'value_map': {'args': 'arg_names',
                                 'kwargs': 'kwarg_pairs',
                                 'varargs': 'varargs',
                                 'keywords': 'keywords'},
                   'children':{'ret':'return'}},
     "return": {'type': Return,
                 'value_map': {'value':'val'}}
    }

    # With inline comments
    {"functions": {'type': FunctionDef, # Each top level entry under functions is a FunctionDef
                   'key': 'name', # The functions key (func1) is the value to the name argument for the FunctionDef
                   'value_map': {'args': 'arg_names',  # Define what args are called in the markups schema
                                 'kwargs': 'kwarg_pairs',
                                 'varargs': 'varargs',
                                 'keywords': 'keywords'},
                   'children':{'ret':'return'}}, # When top-level objects are seen their values will be 
                                                 # pared as well, building a new object from the mapping 
                                                 # they specify and then appended to this object
     "return": {'type': Return,
                 'value_map': {'value':'val'}}
    }

Building a Syntax Map for a Spellbook:
""""""""""""""""""""""""""""""""""""""
Your Syntax Maps top-level keys define what your Spellbook top-level sections are containing. The values of your Syntax Map top-level keys are dictionaries defining how to handle the contents of your Spellbook sections.

In the given example, the only top-level Spellbook section is 'functions'. In the Syntax Map, the 'functions' key's value says several things:

1. For each child node encountered, create a new FunctionObj (defined by 'type')

2. The key defining each child node is the 'name' argument for the FunctionObj

3. The sub-keys of the child node are properties of the FunctionObj. The values of those sub-keys are can be one of two things:

   * If the value is in the value map, it is an argument to FunctionObj

   * If the value is in the children map, it should be placed into the scope of the FunctionObj. The value will be looked up in the Syntax Map top-level to see if it can be be instantiated into a new sourcerer object.

The Syntax Map schema should consist of:
****************************************
* type (required): The class name to instantiate

* key (required): what the key for the node represents

* value_map (required): map properties to arguments to the class

* children: values that should be instantiated and placed into the current nodes child scope


Using a Syntax Map and Spellbook to generate your source:
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Based on the example Syntax Map and the Example YAML, the following will write the resulting source code to stardard out

.. code-block:: python

    from sourcerer import YAMLProcessor

    gen = YAMLProcessor()
    gen.load('sample_data/sample.yml')
    gen.output()



Features
--------

YAPF formatted output to produce pep8 compliant code
