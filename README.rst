===============================
sourcerer
===============================

.. image:: https://img.shields.io/travis/LISTERINE/sourcerer.svg
        :target: https://travis-ci.org/LISTERINE/sourcerer

.. image:: https://img.shields.io/pypi/v/sourcerer.svg
        :target: https://pypi.python.org/pypi/sourcerer

Programatically genrate python source code


Generate code from code:
------------------------
.. code-block:: python

        from yaml import load
        from sourcerer.base import Document
        from sourcerer.callables import FunctionObj, DecoratorObj
        from sourcerer.simple_statements import ReturnObj
        from sys import argv

        # Create a docuemnt to put our code in
        doc = Document()

        # Open our yml file and read it in
        api = load(open(argv[1], 'r').read())
        for path in api['paths']:
            route = [DecoratorObj(name="route", arg_names=[path]), # A decorator: @routename("mypath")
                     FunctionObj(name=path), # A function: def routename():
                     ReturnObj()] # A return statement: return

            doc.create_lineage(route) # Cascade these objects into the main document scope
                                      # ...
                                      # @routename("mypath")
                                      # def routename():
                                      #     return
                                      # ...

        doc.output() # Send output to standard out (output to file optional)

Generate code from Spellbooks
-----------------------------

Source code can also be generated by ingesting and parsing a config document (ex. yaml, json, xml...), known as a Spellbook.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Spellbooks can be parsed into source code be defining a schema, called a Syntax Map.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Example Spellbook (YAML):
"""""""""""""""""""""""""
.. code-block:: yaml

    functions:
        func1:
            args: ['thing1', 'thing2']
            kwargs: {"key1": "val1"}
            varargs: false
            keywords: false
            ret:
                value:
                    true

Example Syntax Map to parse this Spellbook:
"""""""""""""""""""""""""""""""""""""""""""
.. code-block:: python

    {"functions": {'type': FunctionObj,
                   'key': 'name',
                   'value_map': {'args': 'arg_names',
                                 'kwargs': 'kwarg_pairs',
                                 'varargs': 'varargs',
                                 'keywords': 'keywords'},
                   'children':{'ret':'return'}},
     "return": {'type': ReturnObj,
                 'value_map': {'value':'val'}}
    }

Building a Syntax Map for a Spellbook:
--------------------------------------
Your Syntax Maps top-level keys define what your Spellbook top-level sections are containing.
The values of your Syntax Map top-level keys are dictionaries defining how to handle the 
contents of your Spellbook sections.

In the given example, the only top-level Spellbook section is 'functions'. In the Syntax Map, the 
'functions' key's value says several things: 
\    1. For each child node encountered, create a new FunctionObj (defined by 'type')
\    2. The key defining each child node is the 'name' argument for the FunctionObj
\    3. The sub-keys of the child node are properties of the FunctionObj
\        The values of those sub-keys are can be one of two things:
\        1. If the value is in the value map, it is an argument to FunctionObj
\        2. If the value is in the children map, it should be placed into the scope of
\            the FunctionObj. The value will be looked up in the Syntax Map top-level
\            to see if it can be be instantiated into a new sourcerer object.

The Syntax Map schema should consist of:
----------------------------------------

type: The class name to instantiate
key: what the key for the node represents
value_map: map properties to arguments to the class
children: values that should be instantiated and placed into the current
\          nodes child scope




Features
--------

* TODO
